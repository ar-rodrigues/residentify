# Always check the document KNOWN_ISSUES to ensure you didnt commit any of the already know errors.

# Always strive for efficiency and performance. Be aware of LCP (largest contentful paint) to improve UX.

# Dates will be ALWAYS with the format dd/mm/yyyy

# API Documentation Rule (HIGH PRIORITY)

# ALWAYS: Document all API routes with JSDoc @swagger annotations above handler functions (GET, POST, PUT, DELETE, etc.)

# Follow this pattern:

# /\*\*

# \* @swagger

# \* /api/route-path:

# \* get/post/put/delete:

# \* summary: Brief description in English

# \* tags: [TagName]

# \* responses:

# \* 200:

# \* description: Success description

# \* content:

# \* application/json:

# \* schema:

# \* type: object/array

# \* items: (if array)

# \* $ref: '#/components/schemas/ModelName'

# \*/

# When creating new data models, add @swagger schema definitions in types/ files following the pattern in types/database.types.js

# Database Consultation Rule

# ALWAYS: When you need to verify database schema, check existing data, or understand database structure, consult the database directly using a script.

# Follow this pattern (see scripts/generate-schema.js and scripts/test-db-connection.js for reference):

# 1. Create a temporary script in scripts/ directory (e.g., scripts/consult-db-[purpose].js)

# 2. Use the following setup:

# ```javascript

# require('dotenv').config({ path: '.env.local' });

# const { Client } = require('pg');

# const client = new Client({

#   connectionString: process.env.DATABASE_URL,

#   ssl: {

#     rejectUnauthorized: false // Required for Supabase

#   }

# });

# ```

# 3. Run the script to get the information needed

# 4. CRITICAL: Delete the temporary consultation script immediately after use, unless it's a permanent utility script

# 5. Use the information gathered to inform your code changes

# This approach ensures accuracy when working with database schemas, relationships, or existing data patterns.

#Always act as an expert on UI and UX to build the components and the interactivity, using animations and good design practice.
This includes being aware of responsiveness so the UI/UX work well on every device.

# Cursor Code Generation Rules: Semantic HTML and Ant Design

## Primary Directive

Prioritize **Semantic HTML** and **Ant Design (antd) Components** over generic, unstyled tags (div, span) wherever possible. Aim for clean, accessible, and maintainable React code.

## 1. Ant Design Component Preference

Always use the Ant Design component if a dedicated element exists for the purpose.

| Purpose                | Preferred Ant Design Component            | Tags to AVOID                           |
| :--------------------- | :---------------------------------------- | :-------------------------------------- |
| **Headings/Titles**    | Typography.Title (level={1-5})            | h1, h2, h3, h4                          |
| **Paragraph/Text**     | Typography.Text, Typography.Paragraph     | p, span (for blocks of text)            |
| **Buttons**            | Button                                    | <button> (if styled/primary action)     |
| **Layout/Spacing**     | Space, Row, Col, Layout                   | Nested div with manual margins/flex     |
| **Grouping/Container** | Card, Modal, Drawer, Form                 | div (unless a final, necessary wrapper) |
| **Input Fields**       | Input, Select, DatePicker, etc.           | <input>, <select>                       |
| **Icons**              | <*Name*Outlined /> from @ant-design/icons | SVG, custom images for basic icons      |

## 2. Semantic HTML

Use native semantic tags for page structure:

- Use `<header>`, `<nav>`, `<main>`, `<aside>`, `<section>`, `<article>`, `<footer>`.
- Avoid using `<div>` for structural elements that have a semantic counterpart.
- Use `<label>` linked via `htmlFor` (or Ant Design's `Form.Item`) for all form inputs.

## 3. Layout Best Practice

- **Spacing:** Use `<Space>` for horizontal or vertical gaps between inline elements. Do not use manual `margin` or `padding` for this purpose.
- **Grid:** Use `<Row>` and `<Col>` for responsive grid layouts.

## 4. Accessibility (A11y)

- Ensure all images or icons used as content have a meaningful `alt` attribute.
- Interactive elements must be achieved using `<Button>`, `<a>`, or Ant Design equivalents, not by adding `onClick` to a `<div>`.

## 5. React Syntax

- Use functional components and hooks.
- Always destructure props (e.g., `const MyComp = ({ data, loading }) => { ... }`).
- Prefer modern ES6+ syntax (const, let, arrow functions, optional chaining).

# Performance and LCP Optimization Rules

## Page Development Best Practices

### 1. Font Loading

- ALWAYS use Next.js font optimization (`next/font`) for custom fonts
- Use `display: 'swap'` for font-display strategy
- Prefer system fonts when possible for faster LCP
- Apply font variable to HTML element and use in body style

### 2. Image Optimization

- NEVER use `unoptimized` prop on Next.js Image components unless absolutely necessary (e.g., blob URLs that can't be optimized)
- Add `priority` prop to images that are part of the LCP element (above-the-fold images)
- Use appropriate `sizes` prop for responsive images
- Prefer AVIF/WebP formats via Next.js automatic optimization
- Configure image optimization in `next.config.mjs` with proper device sizes and image sizes

### 3. Rendering Strategy

- DO NOT block initial render waiting for data fetching
- Use skeleton loaders or progressive rendering instead of blocking spinners
- Render page structure immediately, show loading states for dynamic content
- Prefer Server Components for data fetching when possible
- When using client components, render structure immediately and fetch data in parallel

### 4. Resource Loading

- Add `preconnect` hints for external APIs (Supabase, etc.) in layout files
- Add `dns-prefetch` for external domains
- Use dynamic imports (`next/dynamic`) for heavy components that aren't immediately visible
- Lazy load components below the fold
- Add font preconnect hints in layout

### 5. Client Components

- Minimize "use client" boundaries - only use when necessary (interactivity, hooks, browser APIs)
- When using client components, render structure immediately
- Fetch data in parallel with rendering, don't block on loading states
- Use loading states within the rendered structure, not as a replacement for it

### 6. Next.js Configuration

- Always configure image optimization in `next.config.mjs`
- Use `optimizePackageImports` for large libraries (antd, etc.)
- Enable compression in production
- Configure proper image formats (AVIF, WebP) and device sizes

### 7. Performance Metrics

- Always be aware of LCP (Largest Contentful Paint) when building pages
- Ensure the LCP element (usually the main heading or hero image) loads quickly
- Prioritize above-the-fold content loading
- Test pages with Lighthouse or similar tools to verify performance improvements
